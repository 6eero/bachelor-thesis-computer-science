\def\thudbabelopt{italian}
\documentclass[target=bach,aauheader=,style=]{thud}

\course{Informatica}
\title{Integrazione di Tecnologie Moderne per un CRM Efficiente: Un Caso Studio su Next.js}
\author{Alessandro Gerotto}
\supervisor{Prof.\ Vincenzo Riccio}
\tutor{Yannick Ponte}

\usepackage[a-1b]{pdfx}
\usepackage[pdfa]{hyperref}
\usepackage{multicol}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{microtype}
\usepackage{geometry}
\usepackage{tocbibind}
\usepackage{array}
\usepackage{enumitem}
    \setlist{itemsep=.08em}
\usepackage{subcaption}
\usepackage{float}


\setlength{\intextsep}{30pt} 


\definecolor{backcolour}{rgb}{0.96,0.96,0.96}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}

% Definizione del linguaggio JavaScript
\lstdefinelanguage{JavaScript}{
    backgroundcolor=\color{backcolour},
    basicstyle=\fontsize{10}{11}\ttfamily, 
    numberstyle=\color{codegray},
    keywords={break, case, catch, continue, debugger, default, delete, do, else, finally, 
              for, function, if, in, instanceof, new, return, switch, throw, try, typeof, 
              var, void, while, with, yield, const, let, async, await, import, export, 
              from, as, interface},
    keywordstyle=\color{blue}\bfseries,
    ndkeywords={class, boolean, implements, this, string, any, number, model, Project},
    ndkeywordstyle=\color{violet}\bfseries,
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{gray}\ttfamily,
    stringstyle=\color{gray}\ttfamily,
    morestring=[b]', morestring=[b]"
}

% Definizione del linguaggio React come estensione di JavaScript
\lstdefinelanguage{React}{
    language=JavaScript,
    alsoletter={<>=-},
    morekeywords={JSX, render, Component, useState, useEffect, useContext, 
                  useReducer, useRef, useCallback, useMemo, createContext, 
                  PropTypes, Fragment, className, =>},
    keywordstyle=\color{teal}\bfseries,
    morecomment=[s][\color{purple}]{<>}{</>},
    morestring=[b]`,
    sensitive=true
}

% Configurazione globale di lstlisting
\lstset{
    language=React,
    extendedchars=true,
    basicstyle=\footnotesize\ttfamily,
    showstringspaces=false,
    numbers=left,
    numberstyle=\footnotesize,
    numbersep=9pt,
    tabsize=2,
    breaklines=true,
    captionpos=b,
    aboveskip=10pt,
    belowskip=10pt
}




\begin{document}
\maketitle
%\begin{dedication}
%	Al mio cane,\par per avermi ascoltato mentre ripassavo le lezioni.
%\end{dedication}

%% Ringraziamenti (opzionali)
%\acknowledgements
%Sed vel lorem a arcu faucibus aliquet eu semper tortor. Aliquam dolor lacus, semper vitae ligula sed, blandit iaculis leo. Nam pharetra lobortis leo nec auctor. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Fusce ac risus pulvinar, congue eros non, interdum metus. Mauris tincidunt neque et aliquam imperdiet. Aenean ac tellus id nibh pellentesque pulvinar ut eu lacus. Proin tempor facilisis tortor, et hendrerit purus commodo laoreet. Quisque sed augue id ligula consectetur adipiscing. Vestibulum libero metus, lacinia ac vestibulum eu, varius non arcu. Nam et gravida velit.

%% Sommario (opzionale)
%\abstract
%Nunc ac dignissim ipsum, quis pulvinar elit. Mauris congue nec leo ornare lobortis. Nulla hendrerit pretium diam nec lobortis. Nullam aliquam laoreet nisl, sit amet facilisis lectus accumsan ut. Duis et elit hendrerit metus venenatis condimentum. Integer id eros molestie, interdum leo sit amet, aliquet metus. Integer fermentum tristique magna, vel luctus neque rhoncus vel. Ut hendrerit et quam et semper. Mauris egestas, odio sed aliquet luctus, magna orci euismod odio, vitae lacinia tellus tellus non lectus. Aliquam urna neque, porta et mattis aliquam, congue sit amet lorem. In ultrices augue sit amet ante vehicula, vitae rhoncus turpis auctor. Donec porta scelerisque eros, at mollis enim imperdiet ut. 

%% Indice
\tableofcontents

%% Lista delle tabelle (se presenti)
%\listoftables

%% Lista delle figure (se presenti)
%\listoffigures

%% Corpo principale del documento
\mainmatter

% Capitolo 1
\chapter{Introduzione}
\section{Introduzione generale}
Il presente lavoro di tesi si propone di analizzare il progetto di un software CRM (Customer Relationship Management) realizzato durante il periodo di tirocinio presso Archeido. L'obiettivo principale del progetto è stato quello di sviluppare una soluzione software efficace e innovativa, in grado di rispondere alle esigenze di gestione delle relazioni con i clienti. 

\noindent  Più nel dettaglio, lo scopo di questo progetto è sviluppare un CRM per gestire e monitorare i progetti in corso all'interno dell'azienda. Quando viene commissionato un nuovo progetto, questo viene registrato nella dashboard del CRM, dove è possibile tenere traccia delle tempistiche, dello stato di avanzamento e delle persone assegnate al progetto. Il sistema consente di monitorare l'intero ciclo di vita del progetto, dalla fase iniziale di pianificazione fino alla consegna finale, garantendo una gestione più efficiente delle risorse e una maggiore trasparenza nel processo operativo.

\noindent Per raggiungere questo obiettivo, è stato adottato un approccio di sviluppo basato su metodologie agili, che hanno consentito di adattare rapidamente le funzionalità del software alle necessità emergenti durante il processo di sviluppo.


\section{Struttura della tesi}

Nelle sezioni seguenti, si fornirà un'analisi dettagliata del prodotto software sviluppato, evidenziando le sue funzionalità principali, gli obiettivi prefissati e gli stakeholder coinvolti. Inoltre, verrà discusso il ciclo di vita adottato per il progetto, i problemi riscontrati e le valutazioni effettuate, nonché il percorso di formazione che ha affiancato il tirocinio. Successivamente, sarà fornita una panoramica delle tecnologie utilizzate e dei requisiti funzionali del sistema, accompagnata da diagrammi esplicativi per facilitare la comprensione del lavoro svolto. 

\noindent Infine, saranno discussi i metodi di testing impiegati, le aree che hanno ricevuto maggior attenzione e quelle che necessiterebbero di ulteriori verifiche. In prospettiva, saranno esplorate le opportunità di ampliamento del progetto, come l'integrazione di nuove funzionalità o l'ottimizzazione di quelle giá esistenti. 

% Capitolo 2
\chapter{Background aziendale}
Questo capitolo fornisce un quadro dettagliato del contesto aziendale di Archeido. Vengono esplorate le specializzazioni di Archeido nell'ingegneria del software e nella trasformazione digitale, ponendo l'accento sull'approccio cloud-native e sull'uso delle metodologie Agile.

\noindent Si presenterà il CRM come una soluzione centrale per il monitoraggio dei progetti, evidenziando le sue funzionalità principali e gli obiettivi strategici che intende perseguire. Inoltre, verranno identificati gli stakeholders coinvolti nel progetto e analizzato il ciclo di vita del software adottato, mettendo in luce l'importanza della flessibilità e dell'adattamento. 

\noindent Infine, saranno discussi i problemi affrontati e le decisioni critiche riguardanti le tecnologie utilizzate e il percorso di formazione intrapreso per garantire un'efficace implementazione del sistema.

\section{Archiedo}
Archeido \cite{archeido2024} è un'azienda specializzata nell'ingegneria del software, focalizzata sulla creazione e implementazione di soluzioni su architetture cloud-native e infrastrutture Cloud, utilizzando principalmente Amazon Web Services. La missione di Archeido è supportare le aziende durante il processo di trasformazione digitale e adozione del Cloud, offrendo un'assistenza sia tecnica che strategica con massima trasparenza. L'azienda adotta e si basa sulle metodologie Agile, garantendo un processo di sviluppo rapido, sicuro ed efficiente.

\section{Prodotto Software}
Il software sviluppato e descritto in questa tesi è un CRM (Customer Relationship Management), progettato per servire come una dashboard centrale per il monitoraggio dei progetti attualmente in corso, come archivio completo di quelli già completati e come piattaforma di pianificazione per i progetti futuri.

\subsection{Funzionalità principali}
Il CRM offre una gestione completa dei progetti, facilitandone le operazioni di creazione, lettura, aggiornamento e cancellazione (CRUD). Inoltre, consente di monitorare gli utenti autorizzati ad accedere alla dashboard, i quali vengono creati tramite inviti generati e condivisi da un super amministratore. A ciascun utente viene assegnato un ruolo specifico, che definisce le regole di visibilità e le autorizzazioni di accesso alle informazioni presenti nella dashboard. Infine, il sistema consente di valutare le performances aziendali, fornendo dati e metriche utili per analizzare l'efficacia dei progetti e il rendimento complessivo del team.

\subsection{Obiettivi del software}
Il CRM ha come obiettivo principale valutare le stime concordate con i clienti, consentendo ai project manager di confrontare le previsioni iniziali stabilite insieme al cliente con i risultati effettivi ottenuti a progetto completato. In questo modo, è possibile identificare eventuali scostamenti e adottare misure correttive tempestive per garantire il successo del progetto. Il CRM sviluppato è dunque uno strumento di monitoraggio che fornisce un supporto strategico volto all'ottimizzazione delle relazioni con i clienti.

\subsection{Stakeholders}
Gli stakeholders di questo progetto includono:

\begin{itemize}
    \item I \textbf{Super Amministratori}, che gestiscono la creazione degli utenti, assegnano loro permessi e regole di visibilità e hanno accesso completo a tutte le sezioni del CRM. 
    \item I \textbf{Project Manager}, i quali ricevono un account per accedere alla dashboard e possono visualizzare solo i progetti a cui sono stati assegnati, limitando l'accesso ad alcune sezioni.
    \item I \textbf{Clienti}, le cui esigenze influenzano l'uso del CRM, poiché il sistema è progettato per rispondere meglio alle loro necessità.
\end{itemize}

\section{Ciclo di vita adottato}
Archeido adotta un ciclo di vita del software basato su metodologie agili, che consentono di gestire progetti in modo iterativo e incrementale. Lo sviluppo Agile si caratterizza per un approccio flessibile, orientato a fornire rapidamente software funzionante al cliente, garantendo aggiornamenti frequenti e miglioramenti continui. In questo contesto, le fasi di specifica, progettazione, sviluppo, validazione ed evoluzione si susseguono in un processo fluido e non fisso, caratterizzato da una continua negoziazione dei requisiti e raccolta di feedback.

\subsection{Plan-based vs Agile development}
La differenza tra Agile e lo sviluppo plan-based risiede principalmente nell'approccio alla gestione dei progetti e nella flessibilità di risposta ai cambiamenti. Nel modello plan-based, il processo di sviluppo è caratterizzato da una pianificazione dettagliata e rigida delle fasi del progetto, dove i requisiti vengono definiti all'inizio e rimangono relativamente statici per tutta la durata del ciclo di vita del progetto. Al contrario, le metodologie Agile, come Scrum e Kanban, pongono l'accento sulla collaborazione continua tra i membri del team e gli stakeholder, consentendo una maggiore adattabilità. I requisiti non sono definitivi e possono evolvere nel corso del progetto, permettendo al team di rispondere rapidamente alle esigenze emergenti.


\section{Formazione e Pair Programming}
Il primo periodo di questo tirocinio è stato dedicato alla formazione, durante la quale è stata approfondita la programmazione funzionale in JavaScript \cite{knowthen2024}, acquisendo le competenze necessarie per scrivere codice più efficiente, leggibile e mantenibile. In seguito, si è analizzato React \cite{udemyreactredux2024}, una libreria JavaScript sviluppata da Facebook per la creazione di interfacce utente interattive e componenti riutilizzabili, facilitando lo sviluppo di applicazioni web complesse. Infine, è stato esplorato Next.js, un framework che estende le capacità di React, permettendo il rendering lato server e facilitando la creazione di applicazioni web performanti.

\noindent Una parte fondamentale della formazione è stata lo sviluppo prevalentemente in modalità di \textbf{Pair Programming}, una pratica essenziale della metodologia \textbf{Extreme Programming (XP)}, che ha velocizzato e semplificato l'apprendimento grazie alla collaborazione diretta tra i membri del team. In questo approccio, due programmatori lavorano insieme su un singolo computer: uno scrive il codice (driver), mentre l'altro lo esamina e fornisce suggerimenti (observer o navigator), favorendo un continuo scambio di conoscenze e un confronto immediato sulle soluzioni.

\noindent L'adozione di XP ha migliorato significativamente la qualità del codice, grazie al feedback immediato e all'integrazione di pratiche agili come il \textbf{refactoring continuo} e la \textbf{revisione condivisa} del lavoro. Questo metodo ha permesso di mettere in pratica fin da subito le nozioni apprese nei corsi di JavaScript funzionale e React sopramenzionati, consentendo di affinare rapidamente le competenze tecniche e di adottare efficacemente pratiche di \textbf{clean code}, garantendo uno sviluppo più strutturato, di qualità e conforme alle best practices della scrittura del codice adottate in Archeido.

\section{Problemi e valutazioni}
Nelle prime fasi dello sviluppo, è stata condotta un'analisi approfondita per valutare quale tra le diverse tecnologie disponibili e librerie grafiche fosse più adatta per la realizzazione del progetto. Alla fine, si è deciso di utilizzare Next.js \cite{nextjs2024} e l'omonima libreria grafica NextUI \cite{nextui2024}. 

\noindent Un altro aspetto cruciale nella fase di sviluppo è stata la scelta tra l'utilizzo di JavaScript puro e l'adozione di TypeScript. Questa decisione ha comportato una valutazione approfondita dei vantaggi e degli svantaggi di entrambe le opzioni, considerando fattori come la tipizzazione statica, la manutenzione del codice e la scalabilità del progetto, approfonditi ulteriormente nelle sezioni seguenti.


% Capitolo 3
\chapter{Background tecnico}

\section{Introduzione}
In questo capitolo, verrà presentato il contesto tecnico del progetto, descrivendo nel dettaglio le tecnologie principali utilizzate: TypeScript, React, Next.js, AWS, Next UI e Tailwind CSS. 

\noindent Queste tecnologie rappresentano la base dell'architettura del sistema e sono state selezionate per le loro caratteristiche che consentono di sviluppare un CRM moderno, efficiente e altamente scalabile. Verranno analizzati i punti di forza di ciascuna tecnologia, con un focus su come ognuna di esse contribuisce alla creazione di un'interfaccia utente reattiva, di un'esperienza utente fluida e di una gestione robusta dei dati.

\section{JavaScript e TypeScript}
JavaScript \cite{wikipedia:javascript} è un linguaggio di programmazione multi-paradigma, concepito per supportare l'orientamento agli eventi. È utilizzato sia per la programmazione lato client, principalmente nel contesto web, sia per la programmazione lato server, grazie all'uso di Node.js. 

\noindent Tuttavia, nel contesto di questo progetto, si è optato per l'utilizzo di \textbf{TypeScript} \cite{wikipedia:typescript}. Questa scelta è stata effettuata durante la fase iniziale di analisi dei requisiti e il motivo principale è stato che TypeScript presenta un \textbf{sistema di tipi statici}. Questo significa che i tipi delle variabili, delle funzioni e delle proprietà vengono definiti al momento della compilazione e non cambiano durante l'esecuzione, permettendo di rilevare gli errori in fase di compilazione piuttosto che durante l'esecuzione. 

\noindent Un altro punto a favore viene evidenziato in contesti dove le applicazioni sono più complesse: TypeScript offre un'architettura di codice più chiara e strutturata, mettendo a disposizione le \textbf{interfacce}. 

\noindent Inoltre, è completamente compatibile con JavaScript, il che consente di integrare senza problemi codice esistente. 

\noindent Un esempio pratico è la funzione \texttt{add}, che esegue la somma dei parametri \texttt{a} e \texttt{b}. In JavaScript, essendo un linguaggio a tipizzazione dinamica, la funzione accetta qualsiasi tipo di valore senza eseguire controlli. Al contrario, in TypeScript la chiamata \texttt{add("5", 10)} genera un errore di compilazione, poiché il linguaggio richiede esplicitamente che i parametri siano di tipo \texttt{number}.

\begin{minipage}[t]{0.45\textwidth}
    \begin{lstlisting}[caption=Coercion in JavaScript]
const add = (a, b) => {
    return a + b;
}   
add("5", 10); // -> "510"
    \end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
    \begin{lstlisting}[caption=Errore in TypeScript]
const add = (a: number, b: number) => {
    return a + b;
}  
add("5", 10); -> // Errore
    \end{lstlisting}
\end{minipage}

\noindent Nell'esempio sopra, JavaScript non genera un errore perché applica automaticamente la \textbf{coercion}, ovvero la conversione implicita di un tipo di dato in un altro per eseguire l'operazione richiesta. Nel caso di \texttt{add("5", 10)}, il numero \texttt{10} viene infatti convertito in una stringa \texttt{"10"} per consentire la concatenazione con \texttt{"5"}, producendo il risultato \texttt{"510"}. Questo accade in quanto l'operatore \texttt{+} in JavaScript somma i valori se entrambi sono numeri, ma effettua la concatenazione se almeno uno dei due è una stringa.

\subsection{Le interfacce in TypeScript}
Durante lo sviluppo di questo progetto, si è dimostrata molto utile la definizione a priori di \textbf{interfacce} come linee guida per i modelli dati. Le interfacce fungono da \textit{blueprint}, definendo i tipi esplicitamente. Ad esempio, per poter creare un nuovo progetto all'interno del CRM, è necessario che esso segua una struttura definita. Attraverso l'uso delle interfacce, è possibile stabilire chiaramente quali proprietà e quali tipi di dati devono essere presenti, garantendo così la corretta integrazione e funzionamento all'interno del sistema. Durante l'analisi dei requisiti, è emerso che ogni progetto registrato deve includere i seguenti campi:

\begin{itemize}
    \item \textbf{ID univoco}: necessario per distinguere i diversi progetti.
    \item \textbf{Codice progetto}: può non essere univoco.
    \item \textbf{Nome del progetto}: la denominazione assegnata al progetto.
    \item \textbf{Data di inizio}: corrisponde alla data in cui il team inizia a lavorare attivamente sul progetto.
    \item \textbf{Data di fine}: corrisponde alla data prevista per la consegna finale del progetto.
    \item \textbf{Project Manager assegnati}: i responsabili del progetto.
    \item \textbf{Stato del progetto}: può essere uno tra i seguenti: \texttt{Not Started}, \texttt{In Progress} o \texttt{Completed}.
    
\end{itemize}

\noindent Questa specifica ha consentito di definire un'interfaccia \texttt{Project}, garantendo che chiunque la implementi debba rispettare lo schema riportato di seguito:

\begin{lstlisting}[language=React, caption=Interfaccia di progetto]
export interface Project {
    id: string;
    code: string;
    name: string;
    startdate: string | number;
    enddate: string | number;
    state: string;
    assignedTo: string;
}
\end{lstlisting}

\noindent Inizialmente, non era previsto che un progetto potesse essere assegnato a specifici Project Manager, quindi il sistema era configurato per consentire a tutti gli utenti di accedere a ogni progetto. Grazie a TypeScript, l'aggiornamento del sistema è stato notevolmente semplificato: modificando l'interfaccia, gli errori di compilazione sono stati segnalati automaticamente in tutte le parti del codice interessate, facilitando l'individuazione delle sezioni da aggiornare. Questo ha reso il processo di adeguamento più rapido e preciso, assicurando al contempo la qualità del software.

\section{React}
React è una libreria JavaScript per la creazione di interfacce utente reattive e componenti riutilizzabili. React consente di costruire interfacce utente utilizzando i cosidetti \textbf{componenti} sfruttando \textbf{JSX} (o \textbf{TSX} nel caso di TypeScript), una sintassi di estensione per JavaScript che permette di scrivere codice che combina quest'ultimo con HTML, in un formato che è più leggibile e comprensibile. Nell'esempio sotto riportato, il componente \texttt{Greeting} viene inizializzato usando JavaScript, ma restituisce un codice HTML:

\begin{lstlisting}[language=React, caption=Esempio di codice React]
const name = 'Alice';   
const Greeting = () => {
    return (
        <h1>
            Hello, {name}!
        </h1>
    )
} 
\end{lstlisting}

\subsection{I componenti}
Un componente React è una funzione JavaScript che rappresenta una parte riutilizzabile e autonoma di un'interfaccia utente in un'applicazione React. I componenti permettono di scomporre l'interfaccia in parti più piccole e gestibili, promuovendo la leggibilità, la manutenzione e il riuso del codice. Questo approccio basato sui componenti e sulla continua estrazione del codice in componenti più semplici garantisce diversi vantaggi:

\begin{itemize}
    \item \textbf{Riuso}: Un componente può essere utilizzato in diverseparti dell'applicazione, riducendo la duplicazione del codice.
    \item \textbf{Isolamento}: Ogni componente ha il proprio stato e le proprie proprietà, rendendo il singolo componente utilizzabile e testabile in ambienti isolati, rimuovendone le dipendenze da ciò che appare al suo esterno.
    \item \textbf{Composizione di componenti}: Una volta sviluppati diversi componenti, React consente di comporli insieme. Ad esempio, un componente \texttt{Card} potrebbe contenere tre componenti più semplici: un'immagine, un titolo e un pulsante. Tale \texttt{Card} potrebbe venir poi usata molteplici volte all'interno di un componente più complesso, come un \texttt{Carousel}.
\end{itemize}

\subsection{Le \textit{props}}
Le props permettono a un componente genitore di fornire informazioni immutabili a un componente figlio, rendendo quest'ultimo più dinamico e flessibile.

\begin{minipage}[t]{0.45\textwidth}
    \begin{lstlisting}[caption=Componente padre]
import React from 'react';
import Greeting from './Greeting';

const App = () => {
    return (
        <div>
            <Greeting name= "Alice" />
            <Greeting name= "Bob" />
        </div>
    );
};  
    \end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
    \begin{lstlisting}[caption=Componente figlio]
import React from 'react';

const Greeting = ({ name }) => {
    return (
        <h1>
            Hello, {name}!
        </h1>
    );
};

export default Greeting;
    \end{lstlisting}
\end{minipage}

\noindent In questo esempio, il componente \texttt{Greeting} (sulla destra) è una funzione che accetta la prop \texttt{name} e restituisce il testo  "Hello," seguito dal valore della prop \texttt{name}, ottenuta dal componente padre. 

\noindent Per esempio, quando viene passato "Alice" come valore, come accade in \texttt{<Greeting name="Alice" />}, il risultato renderizzato sarà un'intestazione \texttt{h1} che riporta "Hello, Alice!", mentre se invece viene passato "Bob" (attraverso \texttt{<Greeting name="Bob" />}), verrà stampato "Hello, Bob!".

\subsection{L'uso degli hook \texttt{useState} e \texttt{useEffect}}
Gli hook sono una caratteristica di React introdotta con la versione 16.8 che consente di utilizzare lo stato e altre funzionalità di React nei componenti funzionali, senza la necessità di convertire il componente in una classe. Gli hook forniscono un modo per gestire lo stato locale, eseguire effetti collaterali, e utilizzare contesti, tra le altre operazioni, rendendo il codice più pulito e riutilizzabile. 

\noindent Gli hook più comuni includono \texttt{useState}, che permette di mantenere e modificare lo stato locale all'interno di un componente, e \texttt{useEffect}, che consente di gestire effetti collaterali, come il caricamento di dati o la registrazione di eventi. 

\noindent Più nel dettaglio, \texttt{useState} restituisce un array composto da due elementi: il valore attuale dello stato (\texttt{selectedProject}) e una funzione per aggiornare tale valore (\texttt{setSelectedProject}). \texttt{useState} accetta un argomento, il quale rappresenta lo stato iniziale.

\begin{center}
\texttt{const [selectedProject, setSelectedProject] = useState<Project>({})}
\end{center}

\noindent \texttt{useEffect} invece, è un hook di React utilizzato per gestire \textbf{effetti collaterali} all'interno di un componente, come operazioni di recupero dati, manipolazione del DOM o registrazione di eventi. Accetta due argomenti: 

\begin{itemize}
    \item Una \textbf{funzione} che contiene il codice da eseguire (\texttt{() => {...}});
    \item Un \textbf{array} di dipendenze che specifica i valori da monitorare (\texttt{[...]}). Quando una di queste dipendenze subisce una modifica, il corpo di \texttt{useEffect} viene eseguito. Tale esecuzione spesso genera effetti collaterali, con conseguente cambiamento di stato. Quando ciò accade, si verifica un rendering aggiornato del componente. Se, come in questo caso, il secondo parametro è un array vuoto, la funzione passata come primo argomento all'hook verrà eseguita soltanto la prima volta.
\end{itemize}

\noindent Un esempio d'uso dei due hooks sopracitati è il seguente, in cui si definisce una funzione chiamata \texttt{foo}. All'interno di questa funzione, viene utilizzato l'hook \texttt{useState} per creare una variabile di stato denominata \texttt{selectedProject} e la relativa funzione di aggiornamento \texttt{setSelectedProject}. L'inizializzazione di \texttt{selectedProject} è impostata su un oggetto vuoto, indicando che inizialmente non contiene dati.

\noindent Successivamente, viene impiegato l'hook \texttt{useEffect}. In questo caso, l'array di dipendenze è vuoto, il che significa che la funzione sarà eseguita solo una volta, quando il componente viene montato per la prima volta. All'interno della funzione \texttt{useEffect}, viene chiamata \texttt{getProjectFromDatabase(1)}, il quale recupera il progetto identificato dall'ID \texttt{1}. Una volta ottenuto il progetto, viene utilizzata \texttt{setSelectedProject} per aggiornare lo stato di \texttt{selectedProject} con il progetto recuperato. Successivamente, questo pseudocodice sarà concretamente implementato.

\begin{lstlisting}[caption=Routing dinamico con Next.js]
const foo = () => {
    const [selectedProject, setSelectedProject] = useState<Project>({});

    useEffect(() => {
        const myProject = getProjectFromDatabase(1)
        setSelectedProject(myProject)
    }, []);
}
\end{lstlisting}

\subsection{L'uso dell'hook \texttt{useMemo}: problemi e soluzioni}
\noindent Si é preso in considerazione anche l'uso dell'hook \texttt{useMemo}. Tale hook viene utilizzato per memorizzare i risultati di una funzione e restituisce un valore memorizzato che cambia solo quando le sue dipendenze cambiano. Questo assicura che i calcoli costosi non vengano ripetuti a ogni rendering, ottimizzando così le prestazioni dei componenti React. Tuttavia, l'uso di \texttt{useMemo} dovrebbe essere impiegato solo quando si tratta di calcoli che richiedono molto tempo o risorse, e i risultati non cambiano tra i rendering, come ad esempio:

\begin{itemize}
    \item \textbf{Cicli annidati};
    \item \textbf{Operazioni ricorsive};
    \item \textbf{Trasformazioni di dati pesanti};
    \item \textbf{Calcoli matematici complessi}.
\end{itemize}

\noindent Tuttavia, un uso eccessivo di questo hook può comportare gravi problemi, come evidenziato da Edvins Antonovs nel suo articolo intitolato \textbf{'useMemo overdose'} \cite{edvins2024usememo} e come illustrato da Giuseppe Funicello durante il ReactJS Day 2024 svolto a Verona il 25/10/2024 \cite{funicello2024reactjsday}. Un abuso di \texttt{useMemo} può portare a:

\begin{itemize}
    \item \textbf{Ottimizzazione prematura}: Nella maggior parte dei casi, quando un componente richiede un notevole potere di calcolo e impiega molto tempo per elaborarsi, si tende a utilizzare questo hook per affrontare il collo di bottiglia, anziché affrontare direttamente la causa del problema.
    \item \textbf{Effetti collaterali indesiderati}: L'uso eccessivo di questo hook può portare a effetti collaterali imprevisti se le dipendenze non sono gestite correttamente. Se le dipendenze sono fornite in modo accurato, si possono evitare situazioni in cui il valore memorizzato non si aggiorna quando dovrebbe, portando a risultati obsoleti o errati.
    \item \textbf{Complessità non necessaria}: Un uso eccesivo di questo hook aumenta la ridondanza nel codice, rendendolo più difficile da comprendere, oscurando la logica reale del componente.
\end{itemize}

\noindent Considerate queste osservazioni, si è optato per evitare l'uso di questo hook, specialmente in vista dell'aggiornamento a \textbf{React 19}, che porterà con sé il nuovo React Compiler. Questo compilatore consente di eliminare del tutto la necessità di utilizzare hook come \texttt{useMemo}, \texttt{useCallback} o \texttt{React.memo}. Questo perché, sfruttando la sua conoscenza di JavaScript e delle regole di React, il compilatore memoizza automaticamente valori o gruppi di valori all'interno dei componenti e degli hook. Qualora vengano rilevate violazioni delle regole, il compilatore salterà automaticamente quei componenti o hook specifici, continuando a elaborare in modo sicuro il resto del codice.



\section{Next.js}
Next.js \cite{nextjsdocs2024} è un \textit{framework}\footnote{Un insieme di strumenti, librerie e regole che forniscono una struttura di base per lo sviluppo di software, facilitando il lavoro dei programmatori.} React per la creazione di applicazioni web full-stack. Next.js permette di usare i componenti React per costruire interfacce utente, fornendo funzionalità aggiuntive e ottimizzazioni. Il framework astrae e configura automaticamente tutti gli strumenti necessari per React, come il \textbf{bundling}, la \textbf{compilazione} e il \textbf{routing}, permettendo di concentrarsi sulla logica dell'applicazione piuttosto che sulla configurazione tecnica. Di seguito, verranno elencati i principali vantaggi di Next.js rispetto a React.

\subsection{Rendering}
Il principale vantaggio di Next.js è l'uso del \textbf{rendering lato server}: i componenti vengono renderizzati direttamente sul server, il cui contenuto viene poi inviato al client. Oltre a questo, Next.js offre la generazione di siti statici (\textbf{Static Site Generation, SSG}), permettendo di pre-renderizzare pagine e componenti con dati statici al momento della costruzione dell'applicazione, rendendoli immediatamente disponibili al caricamento.

\begin{itemize}
    \item Nel \textbf{Client-Side Rendering (CSR)}, i componenti dell'applicazione vengono raggruppati in un \texttt{bundle} e inviati al client per il rendering. Con l'aumentare della complessità dell'applicazione, la dimensione del \texttt{bundle} cresce, poiché deve includere tutti i componenti necessari. Di conseguenza, un \texttt{bundle} più ampio richiede una quantità maggiore di memoria al client per il caricamento completo. Inoltre, il CSR presenta sfide significative per l'ottimizzazione per i motori di ricerca (SEO) e può esporre dati sensibili contenuti all'interno dei componenti.

    \item Il \textbf{Server-Side Rendering (SSR)} affronta queste problematiche eseguendo il rendering dei componenti direttamente sul server. Tuttavia, i componenti server presentano alcune limitazioni: non possono rispondere a eventi del browser, come clic o modifiche, accedere alle API del browser, mantenere uno stato persistente né utilizzare hook come \texttt{useEffect}.
\end{itemize}

\noindent Nelle applicazioni reali, si tende a utilizzare una combinazione di CSR e SSR.L'SSR viene utilizzato nella maggior parte delle sezioni dell'applicazione per ottimizzare i tempi di caricamento, migliorare la SEO e garantire una maggiore sicurezza. Il CSR viene utilizzato solo in situazioni specifiche, per gestire interazioni che richiedono eventi del browser, accesso alle API del browser o gestione dinamica dello stato.

\subsection{App Routing}
Il routing in React gestisce la navigazione tra diverse pagine o componenti all'interno di un'applicazione. Utilizza librerie come \texttt{React Router} per definire percorsi e associare URL specifici a componenti. Quando un utente naviga a un URL, React Router mostra il componente corrispondente senza ricaricare l'intera pagina, permettendo un'esperienza utente fluida e dinamica. In Next.js, il sistema di routing è reso notevolmente più semplice e intuitivo, poiché si basa sulla \textbf{struttura del file system}. Le cartelle rappresentano i percorsi nell'applicazione web, e ogni cartella dedicata a una pagina deve contenere un file chiamato \texttt{page.tsx}\footnote{L'estensione è \texttt{.tsx} perchè si sta usando TypeScript. Con JavaScript sarebbe \texttt{.jsx}.}, che include il contenuto della pagina. La cartella \texttt{app} funge da radice del progetto. Ad esempio, nel CRM è stata creata una cartella \texttt{projects}, al cui interno si trova il file \texttt{page.tsx}. In questo file, è stata definita ed esportata una funzione che restituisce un elemento TSX. Questo componente verrà visualizzato quando si visiterà il percorso \texttt{./projects} nella pagina web.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img/routing.pdf} 
    \caption{App routing \cite{nextjsdocs2024} di Next.js}
\end{figure}

\noindent Un'altra funzionalità di Next.js è la possibilità di implementare il \textbf{routing dinamico}. Questa funzionalità è stata adottata nella pagina \texttt{./projects}, dove selezionando un progetto si accede ai relativi dettagli, con un reindirizzamento a una pagina avente un URL del tipo \texttt{/projects/ID\_PROGETTO}. Naturalmente, ogni progetto ha un URL univoco. Per ottenere ció, all'interno della cartella \texttt{/projects} si è creata un'ulteriore cartella \texttt{[projectId]} contenente un file \texttt{page.tsx} strutturato in questo modo:

\begin{lstlisting}[caption=Routing dinamico con Next.js]
const page = ({ params }: { params: { projectId: string } }) => {
  const [selectedProject, setSelectedProject] = useState<Project>({});
  
  useEffect(() => {
    getProject(params.projectId).then((selectedProject: any) => {
      setSelectedProject(selectedProject as Project);
    });
  }, []);

  return <div>Selected project: {params.slug}</div>
};
\end{lstlisting}

\section{Next UI e Tailwind CSS}
In questo progetto si è deciso di utilizzare Next UI \cite{nextui2024}, una libreria di componenti UI progettata specificamente per Next.js. Essa offre una serie di componenti predefiniti (come bottoni, modali, cards, chips, etc.) e stilizzati che semplificano la creazione di interfacce utente con un estetica accattivante ma pulita ed intuitiva. 

\noindent Un'altra libreria utilizzata per la progettazione del CRM di Archeido è Tailwind CSS: un framework CSS utility-first \footnote{È un approccio alla progettazione di interfacce utente in cui si utilizzano classi CSS per applicare stili direttamente agli elementi HTML, piuttosto che definire classi personalizzate o stili specifici per i componenti.} che permette agli sviluppatori di creare interfacce utente in modo rapido e flessibile. Con Tailwind, è infatti possibile applicare stili direttamente nei file HTML o JSX, rendendo il processo di sviluppo più efficiente. Un esempio è il seguente:

\begin{lstlisting}[caption=Parte del file \texttt{app.tsx} del CRM]
    <main className = "flex flex-col h-screen">
        <Navbar className = "w-screen" signOut={signOut} />
        <div className = "flex flex-row h-full">
            <div className = "col-auto">
                <SideBar />
            </div>
            <div className = "col-auto p-8 grow">{children}</div>
        </div>
    </main> 
\end{lstlisting}


\section{AWS: Amazon Web Service}
Nel contesto del progetto CRM per la gestione dei progetti, è stato scelto Amazon Web Services (AWS) come piattaforma di hosting e gestione delle funzionalità del sistema. AWS offre una vasta gamma di servizi cloud che si integrano in modo efficiente per garantire scalabilità, sicurezza e affidabilità.

\noindent Per il deployment e la gestione del front-end del CRM, è stato impiegato \textbf{AWS Amplify}, un servizio che permette di ospitare applicazioni web con un'integrazione continua (CI/CD). Amplify è stato inizialmente collegato al repository \textbf{BitBucket}, il quale contiene il codice sorgente del progetto. Ogni volta che vengono effettuate modifiche al codice nel repository, Amplify esegue automaticamente un nuovo deployment.

\noindent Per la gestione dell'autenticazione degli utenti, è stato invece utilizzato \textbf{AWS Cognito}, il quale offre una gestione sicura delle credenziali, supportando funzionalità come la multi-factor authentication (MFA) e la rotazione automatica delle chiavi. Il sistema di login del CRM è progettato in modo tale da non permettere la registrazione autonoma degli utenti. Infatti, gli amministratori sono gli unici autorizzati a creare nuovi account e fornire le credenziali di accesso. Questo avviene direttamente dalla dashboard di Cognito, in quanto nel CRM non è stata sviluppata una funzionalità per rendere possibile l'invito di nuovi utenti, essendo uno scenario che trova impiego in pochi casi. Per implementare l'autenticazione, AWS mette a disposizione un componente \texttt{Authenticator}, il quale prende la prop \texttt{hideSignUp}, che permette di nascondere l'opzione per la registrazione.

\begin{lstlisting}[caption=Parte del file \texttt{AuthenticatedLayout.tsx} del CRM]
    const AuthenticatedLayout = ({ children }: any) => {
      return (
        <Authenticator hideSignUp components={components}>
          {(props) => <App {...props}>{children}</App>}
        </Authenticator>
      );
    };
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{img/login.pdf} 
    \caption{Pagina di login}
\end{figure}


% Capitolo 4
\chapter{Descrizione dei requisiti}

\section{Introduzione}
In questo capitolo si descriveranno i requisiti del sistema CRM per la gestione dei progetti, sviluppato durante il tirocinio. Verranno utilizzati diversi strumenti di modellazione per rappresentare i requisiti funzionali e non funzionali del sistema, tra cui diagrammi e pseudocodice per i casi più rilevanti.

\section{Definizione dei requisiti del sistema}
Il sistema CRM è stato progettato per supportare la gestione di progetti aziendali, offrendo funzionalità che spaziano dalla creazione e monitoraggio dei progetti, alla gestione degli utenti. I principali requisiti funzionali delineati durante la fase di raccolta dei requisiti includono:

\begin{itemize}
    \item \textbf{Gestione utenti e ruoli}: gli utenti con ruolo \texttt{ADMIN} possono accedere e apportare modifiche a tutte le sezioni della dashboard: è loro compito assegnare un progetto a uno o più project manager. Gli utenti con ruolo \texttt{PROJECT\_MANAGER} possono visionare, modificare e/o cancellare solo i progetti a cui sono stati assegnati da un utente con ruolo \texttt{ADMIN}. Inoltre, la sezione utenti, disponibile al link \texttt{./users}, è visibile solo ad utenti con ruolo \texttt{ADMIN}.
    \item \textbf{Accesso riservato ad utenti invitati}: Un nuovo utente che desidera utilizzare il CRM deve ricevere un invito via email contenente una password temporanea, inviato da un amministratore. Al primo accesso, l'utente sarà obbligato a cambiare la password temporanea.
    \item \textbf{Creazione di un progetto}: l'utente può creare un progetto, specificando dettagli come \texttt{codice}, \texttt{nome}, \texttt{data\_di\_inizio}, \texttt{data\_di\_fine}, \texttt{stato} (il quale può assumere i valori di \texttt{non\_iniziato}, \texttt{in\_corso} o \texttt{completato}).
    \item \textbf{Modifica di un progetto}: l'utente può modificare un progetto esistente, modificandone i campi sopracitati.
    \item \textbf{Cancellazione di un progetto}: l'utente può cancellare un progetto. 
\end{itemize}

\subsection{Gestione dei ruoli degli utenti e uso del contesto}
Per implementare le regole di visibilità in base ai ruoli degli utenti, è stato aggiunto un campo custom dalla dashboard di Cognito: tale campo è stato definito come \texttt{ROLE} e puó assumere solo i due valori sopracitati. Un utente che accede al CRM, viene memorizzato in un Context \footnote{è uno strumento (un oggetto) che consente di condividere dati (come lo stato o le funzioni) tra componenti senza dover passare esplicitamente le props attraverso ogni livello dell'albero dei componenti. Ogni volta che un campo del contesto varia, la schermata viene ri-renderizzata} globale, il quale "wrappa" l'intera appllicazione. Tale contesto puó essere poi ottenuto in ogni componente della web app. 

\noindent Un esempio di utilizzo avviene nel componente \texttt{SideBar}. Una sidebar è un pannello laterale in un'interfaccia utente che offre accesso rapido finalizzato alla navigazione. In questo caso, il contenuto della sidebar varia in base al ruolo dell'utente attualmente loggato: se l'utente è un admin, ha accesso a tutte le sezioni: Performance, Projects, Orders e Users. Al contrario, se l'utente è un project manager, la sezione Users non sarà visibile. Per gestire le sezioni visibili nella sidebar, si utilizza un array di oggetti, il quale contiene l'insieme di sezioni visibili dall'utente con meno permessi, quindi project manager. 

\begin{lstlisting}[caption=Campi default visibili nella sidebar]
const menusFields = [
    {
        title: "Performances",
        src: "performances",
        icon: <FaRegChartBar className = "scale-150" />,
        visibility: "ALL",
        gap: false
    },
    {
        title: "Projects",
        src: "projects",
        icon: <FaProjectDiagram className = "scale-150" />,
        visibility: "ALL",
        gap: false
    },
    {
        title: "Orders",
        src: "orders",
        icon: <FaClipboardList className = "scale-150" />,
        visibility: "ALL",
        gap: false
    },
];
\end{lstlisting}

\noindent Viene successivamente estratto il ruolo dell'utente loggato dal contesto dell'applicazione:

\begin{lstlisting}[caption=Parte del file \texttt{AuthenticatedLayout.tsx} del CRM]
const user = useContext(AuthContext);
const role = user["custom:role"];
\end{lstlisting}

\noindent In questo modo, la costante \texttt{role} contiene la stringa \texttt{"ADMIN"} o la stringa  \texttt{"PROJECT\_MANAGER"}. Tale valore, viene usato in seguito per decidere se mostrare o meno la sezione Orders:

\begin{lstlisting}[caption=Verifica ruolo]
role === "ADMIN" 
    ? [...Menus, {
        title: "Users",
        src: "users",
        icon: <FaUserFriends className = "scale-150" />,
        visibility: "ADMIN",
        gap: false
    }]
    : Menus;
\end{lstlisting}

\noindent Questo codice verifica se il ruolo dell'utente che ha effetuato il login è "ADMIN". Se è così, crea una nuova lista \texttt{Menus} che include gli elementi esistenti, aggiungendo un nuovo oggetto per la voce di menu "Users". Contraruiamente, se l'utente non è un admin, la lista \texttt{Menus} rimane invariata. 

\noindent L'uso dell'operatore di spread \texttt{...Menus} garantisce che la lista originale non venga modificata, mantenendo l'approccio immutabile tipico della programmazione funzionale.

\subsection{Operazioni di CRUD}
Le operazioni CRUD sono le quattro azioni fondamentali per la gestione dei dati in un database: Create (creare nuovi dati), Read (leggere o visualizzare i dati), Update (aggiornare i dati esistenti) e Delete (eliminare i dati). Il CRM supporta tutte e quattro queste operazioni, implementate seguendo la guida \cite{awsamplifynextjs2024} sulla documentazione di Amplify. Prima di tutto è stato creato il \textbf{modello dati} realtivo ai proggetti

\begin{lstlisting}[caption=Parte del file \texttt{amplify/data/resource.ts}]
const schema = a
.schema({
    Project: a.model({
        code: a.string(),
        name: a.string(),
        startdate: a.string(),
        enddate: a.string(),
        state: a.string(),
        assignedTo: a.string(),
    }),
})
\end{lstlisting}

\noindent Ogni volta che si definisce un modello con \texttt{a.model()}, vengono automaticamente create le seguenti risorse nel cloud:
\begin{itemize}
    \item Una tabella DynamoDB per memorizzare i record.
    \item API per query che permettono di creare, leggere (list/get), modificare ed eliminare i record.
    \item Campi \texttt{createdAt} e \texttt{updatedAt} per tracciare quando ogni record è stato creato o aggiornato.
    \item API in tempo reale per iscriversi agli eventi di creazione, aggiornamento ed eliminazione dei record.
\end{itemize}
\noindent Una volta completata questa operazione, è stata creata una cartella \texttt{api} nella root del progetto. Questa cartella ha lo scopo di raggruppare tutti i file relativi alle chiamate API, ed è stata pensata per mantenere il progetto ben organizzato, estraendo tutte le funzioni che effettuano chiamate al database. Al suo interno, è stata generata un'altra cartella chiamata \texttt{Project}, che a sua volta contiene il file \texttt{endpoints.ts}. Quest'ultimo file si occupa di definire ed esportare le funzioni relative alle operazioni CRUD. 

\noindent Le prime funzioni definite per gestire le operazioni di CRUD sono \texttt{getProject} e \texttt{listProject}. La funzione \texttt{getProject} accetta come argomento un ID di tipo stringa, effettua una richiesta al database e restituisce l'oggetto \texttt{Project} corrispondente. La funzione \texttt{listProject}, invece, recupera e restituisce l'intera lista dei progetti presenti nel database.

\begin{lstlisting}[caption=funzione \texttt{getProject}]
const getProject = async (id: string) => {
    const { data: selectedProject }: Project = await client.models.Project.get({
        id
    });
    return selectedProject;
};
\end{lstlisting}

\begin{lstlisting}[caption=funzione \texttt{listProject}]
const listProject = async () => {
    const { data: projects } = await client.models.Projects.list();
    return projects;
};
\end{lstlisting}

\noindent Graficamente, le due funzioni menzionate sono responsabili dell'estrazione di tutti i dati necessari dal database per popolare la tabella presente all'URL \texttt{/projects}, mostrata nell'immagine qui sotto.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/interfacce/table_project.pdf} 
    \caption{Pagina dei progetti}
\end{figure}

\noindent A questo punto, se si clicca sul pulsante "Create Project" viene caricato l'URL \texttt{./projects/create}, il quale visualizza un modulo vuoto per l'inserimento dei dati del progetto. Per la realizzazione e la gestione di questo modulo, è stata utilizzata la libreria \texttt{Formik}. Dopo aver compilato tutti i campi del modulo, premendo il pulsante "Create" viene invocata la funzione \texttt{createProject}, che riceve come input l'oggetto \texttt{Project} creato tramite il riempimento dei campi e lo invia al database per la sua creazione.

\begin{lstlisting}[caption=funzione \texttt{createProject}]
const createProject = async (projectToCreate: Project) => {
    await client.models.Project.create(project);
};
\end{lstlisting}

\noindent La tabella dei progetti in \texttt{./projects} presenta una colonna denominata \texttt{ACTIONS}. In questa colonna sono visibili due icone. Quando si preme l'icona a forma di cestino, si apre una modale di \textit{danger} che consente di confermare l'eliminazione del progetto. D'altro canto, se si seleziona l'icona a forma di matita, viene caricato l'URL della pagina del progetto con la seguente forma: \texttt{./projects/project\_id}. In tale pagina è possibile effettuare modifiche o procedere all'eliminazione del progetto.

\noindent Per eliminare un progetto, si utilizza la funzione \texttt{deleteProject}, che richiede come argomento l'oggetto \texttt{Project} da eliminare, e tramite il suo ID, esegue la cancellazione:

\begin{lstlisting}[caption=funzione \texttt{deleteProject}]
const deleteProject = async (projectToDelete: Project) => {
    const { id } = projectToDelete;
    await client.models.Project.delete({ id });
};
\end{lstlisting}

\noindent L'aggiornamento di un progetto esistente viene fatto attraverso la funzione \texttt{updateProject}, che accetta come parametro un oggetto \texttt{Project} e aggiorna il database con i nuovi dati forniti:

\begin{lstlisting}[caption=funzione \texttt{updateProject}]
const updateProject = async (projectToUpdate: Project) => {
    await client.models.Project.update(projectToUpdate);
};
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img/interfacce/table_edit.pdf} 
    \caption{Pagina dei progetti}
\end{figure}

\section{Diagrammi}
\subsection{Diagramma dei casi d'uso (Use Case Diagram)}
Il diagramma nella figura mostra il sistema CRM con i diversi attori coinvolti, sia umani che esterni. Nello specifico:

\begin{itemize}
    \item gli \textbf{attori umani} includono "User", "Project Manager" e "Admin" ;
    \item i \textbf{servizi esterni} sono "AWS DynamoDB" e "AWS Cognito".
\end{itemize}

\noindent Gli attori umani interagiscono con il sistema principalmente per la gestione dei progetti e degli utenti. Le operazioni di gestione dei progetti comprendono la creazione, lettura, aggiornamento e cancellazione di progetti, raggruppate sotto il caso d'uso generale "Manage Projects". 

\noindent In modo simile (ma limitato agli attori Admin), la gestione degli utenti è modellata attraverso il caso d'uso "Manage Users", che include funzionalità come invitare nuovi utenti, modificare i ruoli e cancellare utenti già registrati. 

\noindent Il processo di autenticazione è diviso in due casi d'uso principali: il "First Login" per il primo accesso e "Second + Login" per i successivi. Questi casi d'uso si estendono con la gestione degli errori e la verifica delle password. Inoltre, è presente un caso d'uso separato per il cambio della password, "Change Password". Il sistema interagisce con "AWS Cognito" per gestire l'autenticazione e con "AWS DynamoDB" per eseguire operazioni sui dati dei progetti.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/diagrammi/use_case.pdf} 
    \caption{Use Case Diagram}
\end{figure}

\subsection{Sequence diagram}
Il diagramma di sequenza illustra le interazioni tra l'utente, il sistema di autenticazione Cognito, la dashboard del CRM e il database DynamoDB nella gestione dei progetti. Inizia con l'utente che inserisce le credenziali (email e password) nella pagina di login, che inoltra i dati al pool di utenti Cognito per verificarne la validità. Se l'email è presente e la password corretta, il client riceve una risposta di successo, confermando l'accesso; in caso contrario, viene visualizzato un messaggio di errore. Dopo un accesso riuscito, l'utente naviga alla pagina dei progetti (\texttt{/projects}), dove può vedere l'elenco di tutti i progetti disponibili. La dashboard del CRM richiede i dati al database DynamoDB tramite la funzione \texttt{listProject}, e, una volta ottenuta la risposta, i progetti vengono mostrati in una tabella. Quando l'utente desidera creare, modificare o eliminare un progetto, invia una richiesta tramite la dashboard. Per creare un nuovo progetto o cancellarne uno esistente, vengono chiamate le funzioni \texttt{createProject} o \texttt{deleteProject}, rispettivamente. Dopo l'esecuzione di queste operazioni, la dashboard aggiorna la lista dei progetti per mostrare i dati più recenti. Analogamente, se l'utente sceglie di aggiornare un progetto, viene invocata la funzione \texttt{updateProject} e i dati modificati vengono salvati nel database, con la lista dei progetti che si ricarica per riflettere le modifiche.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/diagrammi/sequence.pdf} 
    \caption{Sequence Diagram per il login e le operazioni CRUD sui progetti}
\end{figure}

% Capitolo 5
\chapter{Testing}
Le attività di testing si sono concentrate principalmente sulla verifica delle funzionalità principali dell'applicazione e sulla gestione degli accessi in base ai ruoli definiti. Questo approccio ha portato a un'applicazione operativa e robusta, ma ha anche rivelato lacune significative in termini di accessibilità, un aspetto che merita una riflessione più approfondita, di cui se ne parlerá in seguito.

\section{La Libreria Cypress}
Cypress è un framework di testing end-to-end per applicazioni web, progettato per semplificare la scrittura, l'esecuzione e il debug dei test. Cypress consente di testare l'intero flusso di un'applicazione simulando le interazioni dell'utente con l'interfaccia, come clic, inserimenti di dati e navigazione tra le pagine. La sua sintassi è intuitiva e simile a JavaScript, rendendo la scrittura dei test accessibile anche a chi ha poca esperienza nel campo del testing, motivazione per la quale si è optato per lui in questo progetto.

\noindent Una delle caratteristiche distintive di Cypress è la sua interfaccia grafica (GUI), che permette di eseguire i test in tempo reale, mostrando il comportamento dell'applicazione e il risultato di ogni test mentre vengono eseguiti. Inoltre, offre strumenti di debugging integrati, che consentono agli sviluppatori di vedere esattamente cosa accade nel loro codice durante l'esecuzione dei test.

\subsection{Test end-to-end (E2E) e test dei componenti}
Cypress offre due modalità principali di testing: i test end-to-end (E2E) e i test dei componenti.

\begin{itemize}
    \item I test end-to-end sono progettati per verificare il funzionamento dell'intera applicazione dall'inizio alla fine, simulando l'interazione dell'utente con l'interfaccia. Questa modalità consente di testare scenari complessi in cui più parti dell'applicazione sono coinvolte, garantendo che tutte le parti dell'applicazione funzionino correttamente e che l'esperienza utente sia fluida e priva di errori. 
    \item D'altra parte, i test dei componenti si concentrano su singoli componenti dell'interfaccia utente, consentendo di verificare il comportamento e l'aspetto di ciascun elemento in isolamento. Utilizzando Cypress per i test dei componenti, è possibile testare come un componente reagisce a diverse props o stati, assicurandosi che funzioni correttamente in vari scenari. Questo approccio favorisce un ciclo di sviluppo più rapido e consente di identificare e correggere i bug a livello di singolo componente prima che influenzino l'intera applicazione.
\end{itemize}

\subsection{Testing Unitario}
Il testing unitario è stato utilizzato per testare singole funzioni e componenti del sistema. Ogni funzione, come quelle di creazione, lettura, aggiornamento e cancellazione (CRUD) dei progetti, è stata testata in isolamento per garantire che operassero come previsto.

\subsection{Testing di Integrazione}
Il testing di integrazione è stato condotto per verificare l'interazione tra diversi moduli del sistema, in particolare tra il frontend e il backend. Questo ha incluso test per garantire che le chiamate API al database \texttt{DynamoDB} restituissero i risultati attesi e che il sistema di autenticazione \texttt{AWS Cognito} funzionasse correttamente.

\subsection{Testing di Accettazione}
Il testing di accettazione è stato realizzato coinvolgendo gli utenti finali nel processo. Gli utenti hanno testato le funzionalità del CRM per confermare che il sistema soddisfacesse i requisiti aziendali e che fosse user-friendly.

\section{Casi di Test}
I casi di test sono stati progettati per coprire tutte le funzionalità principali del sistema. Di seguito sono riportati alcuni esempi significativi:

\subsection{Test di Creazione Progetto}
\begin{itemize}
    \item Obiettivo: Verificare che un progetto possa essere creato con successo.
    \item Passi:
    \begin{enumerate}
        \item Accedere come utente con ruolo \texttt{ADMIN}.
        \item Navigare alla pagina di creazione del progetto.
        \item Compilare il modulo con dati validi.
        \item Cliccare sul pulsante "Create".
    \end{enumerate}
    \item Risultato Atteso: Il progetto viene creato e appare nell'elenco dei progetti.
\end{itemize}

\subsection{Test di Modifica Progetto}
\begin{itemize}
    \item Obiettivo: Assicurarsi che un progetto esistente possa essere modificato.
    \item Passi:
    \begin{enumerate}
        \item Accedere come \texttt{PROJECT MANAGER}.
        \item Selezionare un progetto dall'elenco.
        \item Modificare i dettagli del progetto.
        \item Cliccare sul pulsante "Update".
    \end{enumerate}
    \item Risultato Atteso: Le modifiche vengono salvate e visualizzate correttamente.
\end{itemize}

\subsection{Test di Accesso Riservato}
\begin{itemize}
    \item Obiettivo: Verificare che solo gli utenti autorizzati possano accedere a determinate funzionalità.
    \item Passi:
    \begin{enumerate}
        \item Accedere come utente con ruolo \texttt{PROJECT MANAGER}.
        \item Tentare di accedere alla sezione "Users", scrivendo forzatamente nella barra degli url del browser l'url \texttt{/users}.
    \end{enumerate}
    \item Risultato Atteso: L'accesso viene negato e viene visualizzato un messaggio di errore.
\end{itemize}

\section{Risultati del Testing}
Il processo di testing ha portato a risultati positivi. Sono stati identificati e risolti alcuni bug minori, principalmente legati all'interfaccia utente e alla gestione degli stati. Le prestazioni del sistema sono state valutate positivamente, e le operazioni di CRUD hanno mostrato tempi di risposta rapidi e consistenti. Inoltre, il feedback degli utenti durante il testing di accettazione é stato positivo.

\section{Aspetti non testati e proposte di miglioramento}
Durante il processo di testing del sistema CRM sviluppato, ci si è concentrati prevalentemente sulla verifica della corretta implementazione delle funzionalità principali. Tuttavia, gli aspetti riguardanti l'accessibilità della web app non sono stati oggetto di un test approfondito. 

\noindent Ad esempio, uno degli aspetti di accessibilità che non sono stati testati riguarda la navigazione tramite tastiera e la compatibilità con screen reader. La navigazione tramite tastiera rappresenta un elemento molto importante per gli utenti che non possono o preferiscono non utilizzare il mouse, garantendo l'accesso completo alle funzionalità dell'applicazione. Allo stesso modo, non sono stati condotti test di compatibilità con screen reader, strumenti essenziali per gli utenti non vedenti o ipovedenti.

% Capitolo 6
\chapter{Conclusioni}

\section{Obiettivi Raggiunti}
Il sistema CRM per la gestione dei progetti sviluppato durante il tirocinio ha soddisfatto gli obiettivi prefissati, fornendo una soluzione completa e scalabile per la gestione di progetti e utenti all'interno di un'organizzazione. Il progetto ha permesso l'implementazione di funzionalità chiave, tra cui:
\begin{itemize}
    \item La gestione centralizzata di utenti e ruoli, con accessi e permessi controllati basati sui ruoli \texttt{ADMIN} e \texttt{PROJECT MANAGER}, per una maggiore sicurezza e personalizzazione dell'esperienza.
    \item La creazione, modifica e cancellazione di progetti, con tracciamento dello stato e assegnazione dei responsabili, rendendo agevole il monitoraggio e la gestione delle attività.
    \item L'uso di strumenti come \texttt{AWS Cognito} e \texttt{DynamoDB}, che hanno consentito la gestione degli utenti e delle operazioni CRUD, supportando le necessità di autenticazione e archiviazione dei dati.
\end{itemize}

\section{Lezioni apprese}
Lo sviluppo del sistema CRM ha fornito numerose lezioni preziose. Le sfide tecniche affrontate durante lo sviluppo hanno ulteriormente sottolineato l'importanza di una pianificazione adeguata e di valutazioni rigorose per garantire la scalabilità futura del sistema. Dedicar tempo all'inizio del processo per costruire fondamenta solide e scalabili si è dimostrato essenziale, evitando così l'implementazione affrettata di funzionalità che potrebbero portare a problemi di scarsa scalabilità in futuro.

\noindent Inoltre, l'adozione di metodologie Agile ha portato numerosi benefici al progetto. Grazie alla suddivisione del lavoro in iterazioni brevi e incrementali, si é reso possibile ricevere feedback continui e apportare modifiche rapide in base alle esigenze emergenti.

\section{Possibili Sviluppi Futuri}
Il sistema CRM ha posto delle solide basi, ma ci sono opportunità di miglioramento e crescita:
\begin{itemize}
    \item \textbf{Estensione dei Ruoli}: la possibilità di aggiungere ulteriori ruoli con permessi differenziati potrebbe ampliare l'utilizzo del sistema, favorendo una più ampia delega delle responsabilità.
    \item \textbf{Integrazione con Altri Servizi}: l'integrazione con altre API, come strumenti di gestione documentale o di reportistica avanzata, offrirebbe un supporto decisionale migliore agli utenti.
    \item \textbf{Analisi dei Dati}: implementare funzionalità di data analytics per generare report sulle performance dei progetti, aiutando l'azienda a monitorare l'efficienza operativa.
    \item \textbf{Potenziamento della Logica di Gestione degli Stati}: implementare una nuova logica per la gestione e il mantenimento degli stati attraverso l'uso di contesti e del dispatch di azioni. Questo approccio consentirebbe una gestione centralizzata e scalabile degli stati, semplificando la condivisione dei dati tra componenti e migliorando la modularità e la manutenzione del codice, aggiungendo ad esempio, un \texttt{loading} durante ogni cambio di stato/pagina.
    \item \textbf{Sviluppo di test per migliorare l'accessibilità}: si propone di includere test mirati nei seguenti ambiti: innanzitutto, la navigazione tramite tastiera, tramite test automatizzati che verifichino la navigabilità dell'interfaccia, con particolare attenzione agli elementi interattivi come pulsanti, link e moduli di input. Un'altra proposta è l'implementazione di test di compatibilità con screen reader comuni per assicurare che i contenuti siano esposti in modo comprensibile e sequenziale e che l'esperienza utente sia coerente. Altri test utili includono il controllo del contrasto cromatico, per assicurarsi che le scelte di colore siano conformi agli standard WCAG 2.1. Inoltre, un'analisi approfondita delle etichette e delle descrizioni alternative sarebbe fondamentale per garantire che ogni immagine o icona disponga di un testo alternativo adeguato. 
    \item \textbf{Implementazione della gestione utenti}: Attualmente, la pagina dedicata agli utenti in \texttt{/users} consente esclusivamente la visualizzazione degli utenti registrati, senza offrire la possibilità di invitare nuovi utenti o di modificare i loro attributi. Una possibile nuova funzionalità potrebbe prevedere l'integrazione di una gestione completa degli utenti direttamente all'interno della dashboard del CRM, centralizzando così tutte le operazioni in un'unica interfaccia anziché attraverso la dashboard di Cognito. Questa implementazione permetterebbe di inviare inviti a nuovi utenti e di rimuovere quelli esistenti, semplificando il processo di amministrazione e migliorando significativamente l'usabilità del sistema.
    .

\end{itemize}

\section{Conclusioni}
Il progetto CRM realizzato durante il tirocinio rappresenta un efficace strumento di gestione dei progetti aziendali, grazie a una piattaforma sicura e facilmente scalabile. Questo progetto, oltre a consolidare competenze tecniche nella gestione e nello sviluppo di sistemi basati su cloud, ha aperto la strada a miglioramenti futuri e a possibili nuove funzionalità, rafforzando il contributo dell'applicazione nel supportare i processi aziendali.






%\appendix
%\part{Appendici}
%\chapter{Titolo della prima appendice}

%% Bibliografia
\bibliographystyle{plain_\languagename}
\bibliography{thud}
\end{document}